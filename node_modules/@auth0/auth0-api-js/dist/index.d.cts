import * as jose from 'jose';
export { MissingClientAuthError, TokenExchangeError } from '@auth0/auth0-auth-js';

interface ApiClientOptions {
    /**
     * The Auth0 domain to use for authentication.
     * @example 'example.auth0.com' (without https://)
     */
    domain: string;
    /**
     * The expected JWT Access Token audience ("aud") value.
     */
    audience: string;
    /**
     * The optional client ID of the application.
     * Required when using the `getAccessTokenForConnection` or `getTokenByExchangeProfile` methods.
     */
    clientId?: string;
    /**
     * The optional client secret of the application.
     * At least one of `clientSecret` or `clientAssertionSigningKey` is required when using the `getAccessTokenForConnection` or `getTokenByExchangeProfile` methods.
     */
    clientSecret?: string;
    /**
     * The optional client assertion signing key to use.
     * At least one of `clientSecret` or `clientAssertionSigningKey` is required when using the `getAccessTokenForConnection` or `getTokenByExchangeProfile` methods.
     */
    clientAssertionSigningKey?: string | CryptoKey;
    /**
     * The optional client assertion signing algorithm to use with the `clientAssertionSigningKey`.
     * If not provided, it will default to `RS256`.
     */
    clientAssertionSigningAlg?: string;
    /**
     * Optional, custom Fetch implementation to use.
     */
    customFetch?: typeof fetch;
}
interface AccessTokenForConnectionOptions {
    /**
     * The name of the connection to get the token for.
     */
    connection: string;
    /**
     * The access token used as the subject token to be exchanged.
     */
    accessToken: string;
    /**
     * An optional login hint to pass to the connection.
     */
    loginHint?: string;
}
interface ConnectionTokenSet {
    /**
     * The access token issued by the connection.
     */
    accessToken: string;
    /**
     * The scope granted by the connection.
     */
    scope: string | undefined;
    /**
     * The access token expiration time, represented in seconds since the Unix epoch.
     */
    expiresAt: number;
    /**
     * The name of the connection the token was requested for.
     */
    connection: string;
    /**
     * An optional login hint that was passed during the exchange.
     */
    loginHint?: string;
}
/**
 * Configuration options for exchanging a token via a Custom Token Exchange Profile (RFC 8693).
 *
 * This interface supports **Custom Token Exchange** for custom token types.
 * Auth0 also supports **Access Token Exchange with Token Vault** for external provider's access tokens.
 *
 * @see {@link https://auth0.com/docs/authenticate/custom-token-exchange Custom Token Exchange Documentation}
 * @see {@link https://auth0.com/docs/secure/tokens/token-vault/access-token-exchange-with-token-vault Token Vault Documentation}
 *
 * @example
 * ```typescript
 * const options: ExchangeProfileOptions = {
 *   subjectTokenType: 'urn:example:custom-token',
 *   audience: 'https://api.backend.com',
 *   scope: 'read:data write:data'
 * };
 * ```
 */
interface ExchangeProfileOptions {
    /**
     * URI identifying the type of the subject token being exchanged.
     * Must match a `subject_token_type` configured in a Token Exchange Profile.
     *
     * For custom token types, this must be a URI scoped under your own ownership,
     * such as http://acme.com/legacy-token or urn:acme:legacy-token.
     *
     * Reserved namespaces (cannot be used): http://auth0.com, https://auth0.com,
     * http://okta.com, https://okta.com, urn:ietf, urn:auth0, urn:okta
     *
     * @example "urn:acme:legacy-token"
     * @example "http://acme.com/mcp-token"
     */
    subjectTokenType: string;
    /**
     * The audience (API identifier) for which tokens will be issued.
     * Must match an API identifier configured in your Auth0 tenant.
     *
     * @example "https://api.backend.com"
     */
    audience: string;
    /**
     * Space-separated list of OAuth 2.0 scopes to request for the exchanged token.
     *
     * @example "read:data write:data"
     */
    scope?: string;
    /**
     * Type of token being requested (RFC 8693).
     * Defaults to access_token if not specified.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc8693#section-2.1 RFC 8693 Section 2.1}
     *
     * @example "urn:ietf:params:oauth:token-type:access_token"
     * @example "urn:ietf:params:oauth:token-type:refresh_token"
     */
    requestedTokenType?: string;
}
/**
 * Result returned from a token exchange via a Custom Token Exchange Profile (RFC 8693).
 * Contains the exchanged tokens and metadata.
 */
interface TokenExchangeProfileResult {
    /**
     * The access token issued for the target backend API.
     */
    accessToken: string;
    /**
     * The access token expiration time, represented in seconds since the Unix epoch.
     */
    expiresAt: number;
    /**
     * The scope granted by Auth0 for the exchanged token.
     */
    scope?: string;
    /**
     * ID token containing user identity claims (if requested via openid scope).
     */
    idToken?: string;
    /**
     * Refresh token for obtaining new access tokens (if requested via offline_access scope).
     */
    refreshToken?: string;
    /**
     * Token type (typically "Bearer").
     */
    tokenType?: string;
    /**
     * RFC 8693 issued token type indicator (e.g., "urn:ietf:params:oauth:token-type:access_token").
     */
    issuedTokenType?: string;
}
interface VerifyAccessTokenOptions {
    /**
     * The access token to verify.
     */
    accessToken: string;
    /**
     * Additional claims that are required to be present in the access token.
     * If the access token does not contain these claims, the verification will fail.
     * Apart from the claims defined in this array, the SDK will also enforce: `iss`, `aud`, `exp` and `iat`.
     */
    requiredClaims?: string[];
}

declare class ApiClient {
    #private;
    constructor(options: ApiClientOptions);
    /**
     * Verifies the provided access token against the ApiClient's configured audience.
     *
     * This method validates the JWT signature using the Auth0 tenant's JWKS and verifies
     * standard claims including issuer, expiration, and issued-at time. The audience claim
     * is verified against the audience configured when constructing the ApiClient.
     *
     * @param options Options containing the access token and optional required claims.
     * @returns Promise resolving to the verified token payload containing all JWT claims.
     * @throws {VerifyAccessTokenError} When verification fails due to invalid signature,
     *                                   expired token, mismatched audience, or missing required claims.
     *
     * @example
     * ```typescript
     * const apiClient = new ApiClient({
     *   domain: 'example.auth0.com',
     *   audience: 'https://api.example.com', // This audience is used for verification
     *   clientId: 'client123',
     *   clientSecret: 'secret'
     * });
     *
     * const payload = await apiClient.verifyAccessToken({
     *   accessToken: 'eyJhbGc...'
     * });
     * ```
     */
    verifyAccessToken(options: VerifyAccessTokenOptions): Promise<jose.JWTPayload>;
    /**
     * Retrieves an access token for a connection.
     *
     * @param options - Options for retrieving an access token for a connection.
     *
     * @throws {TokenForConnectionError} If there was an issue requesting the access token.
     *
     * @returns The Connection Token Set, containing the access token for the connection, as well as additional information.
     */
    getAccessTokenForConnection(options: AccessTokenForConnectionOptions): Promise<ConnectionTokenSet>;
    /**
     * Exchanges a token via a Custom Token Exchange Profile for a different API audience while preserving user identity (RFC 8693).
     *
     * This method supports **Custom Token Exchange** for custom token types via a configured Token Exchange Profile.
     *
     * For **Access Token Exchange with Token Vault** (external provider's access tokens), use {@link getAccessTokenForConnection} instead.
     *
     * **Note**: This method requires a confidential client (client credentials must be configured).
     * While Custom Token Exchange Early Access technically permits public clients, this implementation
     * currently requires client authentication. Public client support may be added in a future release.
     *
     * @param subjectToken - The raw token to be exchanged (without "Bearer " prefix)
     * @param options - Configuration for the token exchange
     *
     * @returns A promise that resolves with the {@link TokenExchangeProfileResult}
     *
     * @throws {TokenExchangeError} When client credentials are not configured or exchange fails
     *
     * @see {@link https://auth0.com/docs/authenticate/custom-token-exchange Custom Token Exchange Documentation}
     *
     * @example
     * ```typescript
     * const result = await apiClient.getTokenByExchangeProfile(
     *   userToken,
     *   {
     *     subjectTokenType: 'urn:example:custom-token',
     *     audience: 'https://api.backend.com',
     *     scope: 'read:data write:data',
     *   }
     * );
     * ```
     */
    getTokenByExchangeProfile(subjectToken: string, options: ExchangeProfileOptions): Promise<TokenExchangeProfileResult>;
}

/**
 * RFC 9728 - OAuth 2.0 Protected Resource Metadata
 * https://datatracker.ietf.org/doc/html/rfc9728
 */
/**
 * Supported methods of sending an OAuth 2.0 bearer token
 */
declare enum BearerMethod {
    HEADER = "header",
    BODY = "body",
    QUERY = "query"
}
/**
 * Supported signing algorithms
 */
declare enum SigningAlgorithm {
    RS256 = "RS256",
    RS384 = "RS384",
    RS512 = "RS512",
    ES256 = "ES256",
    ES384 = "ES384",
    ES512 = "ES512",
    PS256 = "PS256",
    PS384 = "PS384",
    PS512 = "PS512",
    HS256 = "HS256",
    HS384 = "HS384",
    HS512 = "HS512"
}
/**
 * Grant types supported
 */
declare enum GrantType {
    AUTHORIZATION_CODE = "authorization_code",
    IMPLICIT = "implicit",
    PASSWORD = "password",
    CLIENT_CREDENTIALS = "client_credentials",
    REFRESH_TOKEN = "refresh_token",
    JWT_BEARER = "urn:ietf:params:oauth:grant-type:jwt-bearer",
    SAML2_BEARER = "urn:ietf:params:oauth:grant-type:saml2-bearer",
    DEVICE_CODE = "urn:ietf:params:oauth:grant-type:device_code"
}
/**
 * Interface for Protected Resource Metadata
 */
interface IProtectedResourceMetadata {
    resource: string;
    authorization_servers: string[];
    jwks_uri?: string;
    scopes_supported?: string[];
    bearer_methods_supported?: BearerMethod[];
    resource_signing_alg_values_supported?: SigningAlgorithm[];
    resource_name?: string;
    resource_documentation?: string;
    resource_policy_uri?: string;
    resource_tos_uri?: string;
    tls_client_certificate_bound_access_tokens?: boolean;
    authorization_details_types_supported?: string[];
    dpop_signing_alg_values_supported?: string[];
    dpop_bound_access_tokens_required?: boolean;
}
/**
 * Builder for creating a ProtectedResourceMetadata instance
 *
 * @example
 * ```typescript
 * const metadata = new ProtectedResourceMetadataBuilder('https://api.example.com', ['https://auth.example.com'])
 *   .withJwksUri('https://api.example.com/.well-known/jwks.json')
 *   .withScopesSupported(['read', 'write'])
 *   .build();
 * // serialize to json
 * const json = metadata.toJSON();
 * ```
 */
declare class ProtectedResourceMetadataBuilder {
    private readonly props;
    /**
     * Constructor for the builder
     * @param resource - The protected resource identifier (REQUIRED)
     * @param authorization_servers - Array of authorization server URLs (REQUIRED)
     */
    constructor(resource: string, authorization_servers: string[]);
    get properties(): IProtectedResourceMetadata;
    /**
     * Builds the ProtectedResourceMetadata
     */
    build(): ProtectedResourceMetadata;
    /**
     * Builder method to add JWKS URI
     */
    withJwksUri(jwks_uri: string): this;
    /**
     * Builder method to add supported scopes
     */
    withScopesSupported(scopes_supported: string[]): this;
    /**
     * Builder method to add supported bearer methods
     */
    withBearerMethodsSupported(bearer_methods_supported: BearerMethod[]): this;
    /**
     * Builder method to add supported resource signing algorithms
     */
    withResourceSigningAlgValuesSupported(resource_signing_alg_values_supported: SigningAlgorithm[]): this;
    /**
     * Builder method to add resource_name
     */
    withResourceName(resource_name: string): this;
    /**
     * Builder method to add resource documentation URL
     */
    withResourceDocumentation(resource_documentation: string): this;
    /**
     * Builder method to add resource policy URI
     */
    withResourcePolicyUri(resource_policy_uri: string): this;
    /**
     * Builder method to add resource terms of service URI
     */
    withResourceTosUri(resource_tos_uri: string): this;
    /**
     * Builder method to enable TLS client certificate bound access tokens
     */
    withTlsClientCertificateBoundAccessTokens(tls_client_certificate_bound_access_tokens: boolean): this;
    /**
     * Builder method to add supported authorization details types
     */
    withAuthorizationDetailsTypesSupported(authorization_details_types_supported: string[]): this;
    /**
     * Builder method to add supported DPoP signing algorithms
     */
    withDpopSigningAlgValuesSupported(dpop_signing_alg_values_supported: string[]): this;
    /**
     * Builder method to require DPoP bound access tokens
     */
    withDpopBoundAccessTokensRequired(dpop_bound_access_tokens_required: boolean): this;
}
declare class ProtectedResourceMetadata {
    #private;
    constructor(builder: ProtectedResourceMetadataBuilder);
    /**
     * Convert to JSON representation
     */
    toJSON(): IProtectedResourceMetadata;
}

/**
 * Error thrown when the transaction is missing.
 */
declare class MissingTransactionError extends Error {
    code: string;
    constructor(message?: string);
}
/**
 * Error thrown when verifying the access token.
 */
declare class VerifyAccessTokenError extends Error {
    code: string;
    constructor(message: string);
}
/**
 * Error thrown when request is missing a valid token or
 * multiple auth methods used
 */
declare class InvalidRequestError extends Error {
    code: string;
    constructor(message: string);
}
/**
 * Error thrown when a required argument is missing.
 */
declare class MissingRequiredArgumentError extends Error {
    code: string;
    constructor(argument: string);
}

/**
 * Header-like object that can represent headers from different HTTP frameworks
 */
type HeadersLike = Record<string, unknown> & {
    authorization?: string;
    'content-type'?: string;
};
/**
 * Query-like object for URL query parameters
 */
type QueryLike = Record<string, unknown> & {
    access_token?: string;
};
/**
 * Body-like object for form-encoded request body
 */
type BodyLike = QueryLike;
/**
 * Extracts a Bearer token from HTTP request according to RFC 6750.
 * Supports all three methods defined in the RFC:
 * - Authorization header (Section 2.1)
 * - Form-encoded body parameter (Section 2.2)
 * - URI query parameter (Section 2.3)
 *
 * @param headers - HTTP headers object
 * @param query - Query parameters object (optional)
 * @param body - Request body object (optional)
 * @returns The extracted token string
 * @throws {InvalidRequestError} When no token is found or multiple methods are used
 *
 * @example
 * ```typescript
 * // Authorization header method (recommended)
 * const token1 = getToken({ authorization: 'Bearer mF_9.B5f-4.1JqM' });
 *
 * // Query parameter method
 * const token2 = getToken({}, { access_token: 'mF_9.B5f-4.1JqM' });
 *
 * // Form body method
 * const token3 = getToken(
 *   { 'content-type': 'application/x-www-form-urlencoded' },
 *   {},
 *   { access_token: 'mF_9.B5f-4.1JqM' }
 * );
 *
 * // Express.js usage
 * const token4 = getToken(req.headers, req.query, req.body);
 * ```
 *
 * @see https://datatracker.ietf.org/doc/html/rfc6750#section-2 - RFC 6750 Section 2
 */
declare function getToken(headers: HeadersLike, query?: QueryLike, body?: BodyLike): string;

export { type AccessTokenForConnectionOptions, ApiClient, type ApiClientOptions, BearerMethod, type ConnectionTokenSet, type ExchangeProfileOptions, GrantType, type IProtectedResourceMetadata, InvalidRequestError, MissingRequiredArgumentError, MissingTransactionError, ProtectedResourceMetadataBuilder, SigningAlgorithm, type TokenExchangeProfileResult, VerifyAccessTokenError, type VerifyAccessTokenOptions, getToken };

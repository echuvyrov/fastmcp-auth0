import { IDToken, TokenEndpointResponse, TokenEndpointResponseHelpers } from 'openid-client';

interface AuthClientOptions {
    /**
     * The Auth0 domain to use for authentication.
     * @example 'example.auth0.com' (without https://)
     */
    domain: string;
    /**
     * The client ID of the application.
     */
    clientId: string;
    /**
     * The client secret of the application.
     */
    clientSecret?: string;
    /**
     * The client assertion signing key to use.
     */
    clientAssertionSigningKey?: string | CryptoKey;
    /**
     * The client assertion signing algorithm to use.
     */
    clientAssertionSigningAlg?: string;
    /**
     * Authorization Parameters to be sent with the authorization request.
     */
    authorizationParams?: AuthorizationParameters;
    /**
     * Optional, custom Fetch implementation to use.
     */
    customFetch?: typeof fetch;
    /**
     * Indicates whether the SDK should use the mTLS endpoints if they are available.
     *
     * When set to `true`, using a `customFetch` is required.
     */
    useMtls?: boolean;
}
interface AuthorizationParameters {
    /**
     * The scope to use for the authentication request.
     */
    scope?: string;
    /**
     * The audience to use for the authentication request.
     */
    audience?: string;
    /**
     * The redirect URI to use for the authentication request, to which Auth0 will redirect the browser after the user has authenticated.
     * @example 'https://example.com/callback'
     */
    redirect_uri?: string;
    [key: string]: unknown;
}
interface BuildAuthorizationUrlOptions {
    /**
     * Indicates whether the authorization request should be done using a Pushed Authorization Request.
     */
    pushedAuthorizationRequests?: boolean;
    /**
     * Authorization Parameters to be sent with the authorization request.
     */
    authorizationParams?: AuthorizationParameters;
}
interface BuildAuthorizationUrlResult {
    /**
     * The URL to use to authenticate the user, including the query parameters.
     * Redirect the user to this URL to authenticate.
     * @example 'https://example.auth0.com/authorize?client_id=...&scope=...'
     */
    authorizationUrl: URL;
    /**
     * The code verifier that is used for the authorization request.
     */
    codeVerifier: string;
}
interface BuildLinkUserUrlOptions {
    /**
     * The connection for the user to link.
     */
    connection: string;
    /**
     * The scope for the connection.
     */
    connectionScope: string;
    /**
     * The id token of the user initiating the link.
     */
    idToken: string;
    /**
     * Additional authorization parameters to be sent with the link user request.
     */
    authorizationParams?: AuthorizationParameters;
}
interface BuildLinkUserUrlResult {
    /**
     * The URL to use to link the user, including the query parameters.
     * Redirect the user to this URL to link the user.
     * @example 'https://example.auth0.com/authorize?request_uri=urn:ietf:params:oauth:request_uri&client_id=...'
     */
    linkUserUrl: URL;
    /**
     * The code verifier that is used for the link user request.
     */
    codeVerifier: string;
}
interface BuildUnlinkUserUrlOptions {
    /**
     * The connection for the user to unlink.
     */
    connection: string;
    /**
     * The id token of the user initiating the unlink.
     */
    idToken: string;
    /**
     * Additional authorization parameters to be sent with the unlink user request.
     */
    authorizationParams?: AuthorizationParameters;
}
interface BuildUnlinkUserUrlResult {
    /**
     * The URL to use to unlink the user, including the query parameters.
     * Redirect the user to this URL to unlink the user.
     * @example 'https://example.auth0.com/authorize?request_uri=urn:ietf:params:oauth:request_uri&client_id=...'
     */
    unlinkUserUrl: URL;
    /**
     * The code verifier that is used for the unlink user request.
     */
    codeVerifier: string;
}
interface TokenByClientCredentialsOptions {
    /**
     * The audience for which the token should be requested.
     */
    audience: string;
    /**
     * The organization for which the token should be requested.
     */
    organization?: string;
}
interface TokenByRefreshTokenOptions {
    /**
     * The refresh token to use to get a token.
     */
    refreshToken: string;
}
interface TokenByCodeOptions {
    /**
     * The code verifier that is used for the authorization request.
     */
    codeVerifier: string;
}
/**
 * @deprecated Since v1.2.0. Use {@link TokenVaultExchangeOptions} with {@link exchangeToken}.
 * This interface remains for backward compatibility and is planned for removal in v2.0.
 */
interface TokenForConnectionOptions {
    /**
     * The connection for which a token should be requested.
     */
    connection: string;
    /**
     * Login hint to inform which connection account to use, can be useful when multiple accounts for the connection exist for the same user.
     */
    loginHint?: string;
    /**
     * The refresh token to use to get an access token for the connection.
     */
    refreshToken?: string;
    /**
     * The access token to use to get an access token for the connection.
     */
    accessToken?: string;
}
/**
 * Configuration options for Token Exchange via Token Exchange Profile (RFC 8693).
 *
 * Token Exchange Profiles enable first-party on-behalf-of flows where you exchange
 * a custom token for Auth0 tokens targeting a different API, while preserving user identity.
 *
 * **Requirements:**
 * - Requires a confidential client (client_secret or client_assertion must be configured)
 * - Requires a Token Exchange Profile to be created in Auth0 via the Management API
 * - The subject_token_type must match a profile configured in your tenant
 * - Reserved namespaces are validated by the Auth0 platform; the SDK does not pre-validate
 * - The organization parameter is not supported during Early Access
 *
 * @see {@link https://auth0.com/docs/authenticate/custom-token-exchange Custom Token Exchange Documentation}
 * @see {@link https://auth0.com/docs/api/management/v2/token-exchange-profiles Token Exchange Profiles API}
 * @see {@link https://www.rfc-editor.org/rfc/rfc8693 RFC 8693: OAuth 2.0 Token Exchange}
 *
 * @example Basic usage
 * ```typescript
 * const response = await authClient.exchangeToken({
 *   subjectTokenType: 'urn:acme:custom-token',
 *   subjectToken: userProvidedToken,
 *   audience: 'https://api.example.com',
 *   scope: 'openid profile read:data'
 * });
 * ```
 *
 * @example With custom parameters for Action validation
 * ```typescript
 * const response = await authClient.exchangeToken({
 *   subjectTokenType: 'urn:acme:legacy-token',
 *   subjectToken: legacyToken,
 *   audience: 'https://api.example.com',
 *   scope: 'openid offline_access',
 *   extra: {
 *     device_id: 'device-12345',
 *     session_token: 'sess-abc'
 *   }
 * });
 * ```
 */
interface ExchangeProfileOptions {
    /**
     * A URI that identifies the type of the subject token being exchanged.
     * Must match a subject_token_type configured in a Token Exchange Profile.
     *
     * For custom token types, this must be a URI scoped under your own ownership.
     *
     * **Reserved namespaces** (validated by Auth0 platform):
     * - http://auth0.com, https://auth0.com
     * - http://okta.com, https://okta.com
     * - urn:ietf, urn:auth0, urn:okta
     *
     * @example "urn:acme:legacy-token"
     * @example "http://acme.com/mcp-token"
     */
    subjectTokenType: string;
    /**
     * The token to be exchanged.
     */
    subjectToken: string;
    /**
     * The unique identifier (audience) of the target API.
     * Must match an API identifier configured in your Auth0 tenant.
     *
     * @example "https://api.example.com"
     */
    audience?: string;
    /**
     * Space-separated list of OAuth 2.0 scopes to request.
     * Scopes must be allowed by the target API and token exchange profile configuration.
     *
     * @example "openid profile email"
     * @example "openid profile read:data write:data"
     */
    scope?: string;
    /**
     * Type of token being requested (RFC 8693).
     * Defaults to access_token if not specified.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc8693#section-2.1 RFC 8693 Section 2.1}
     * @example "urn:ietf:params:oauth:token-type:access_token"
     * @example "urn:ietf:params:oauth:token-type:refresh_token"
     */
    requestedTokenType?: string;
    /**
     * Additional custom parameters accessible in Auth0 Actions via event.request.body.
     *
     * Use for context like device fingerprints, session IDs, or business metadata.
     * Cannot override reserved OAuth parameters.
     *
     * Array values are limited to 20 items per key to prevent DoS attacks.
     *
     * **Security Warning**: Never include PII (Personally Identifiable Information),
     * secrets, passwords, or sensitive data in extra parameters. These values may be
     * logged by Auth0, stored in audit trails, or visible in network traces. Use only
     * for non-sensitive metadata like device IDs, session identifiers, or request context.
     *
     * @example
     * ```typescript
     * {
     *   device_fingerprint: 'a3d8f7b2c1e4...',
     *   session_id: 'sess_abc123',
     *   risk_score: '0.95'
     * }
     * ```
     */
    extra?: Record<string, string | string[]>;
}
/**
 * Configuration options for Access Token Exchange with Token Vault.
 *
 * Access Token Exchange with Token Vault enables secure access to third-party APIs (e.g., Google Calendar, Salesforce)
 * by exchanging an Auth0 token for an external provider's access token without the client handling
 * the external provider's refresh tokens.
 *
 * **Requirements:**
 * - Requires a confidential client (client credentials must be configured)
 * - Token Vault must be enabled for the specified connection
 * - The connection must support the requested token type
 *
 * @see {@link https://auth0.com/docs/secure/tokens/token-vault Token Vault Documentation}
 * @see {@link https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault Configure Token Vault}
 *
 * @example Using an access token
 * ```typescript
 * const response = await authClient.exchangeToken({
 *   connection: 'google-oauth2',
 *   subjectToken: auth0AccessToken,
 *   subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
 *   loginHint: 'user@example.com'
 * });
 * ```
 *
 * @example Using a refresh token
 * ```typescript
 * const response = await authClient.exchangeToken({
 *   connection: 'google-oauth2',
 *   subjectToken: auth0RefreshToken,
 *   subjectTokenType: 'urn:ietf:params:oauth:token-type:refresh_token'
 * });
 * ```
 */
interface TokenVaultExchangeOptions {
    /**
     * The name of the connection configured in Auth0 with Token Vault enabled.
     *
     * @example "google-oauth2"
     * @example "salesforce"
     */
    connection: string;
    /**
     * The Auth0 token to exchange (access token or refresh token).
     */
    subjectToken: string;
    /**
     * Type of the Auth0 token being exchanged.
     *
     * **Important**: Defaults to `urn:ietf:params:oauth:token-type:access_token` if not specified.
     * If you're passing a refresh token, you MUST explicitly set this to
     * `urn:ietf:params:oauth:token-type:refresh_token` to avoid token type mismatch errors.
     *
     * @default 'urn:ietf:params:oauth:token-type:access_token'
     */
    subjectTokenType?: 'urn:ietf:params:oauth:token-type:access_token' | 'urn:ietf:params:oauth:token-type:refresh_token';
    /**
     * Type of token being requested from the external provider.
     * Typically defaults to the external provider's access token type.
     */
    requestedTokenType?: string;
    /**
     * Hint about which external provider account to use.
     * Useful when multiple accounts for the connection exist for the same user.
     *
     * @example "user@example.com"
     * @example "external_user_id_123"
     */
    loginHint?: string;
    /**
     * Space-separated list of scopes to request from the external provider.
     *
     * @example "https://www.googleapis.com/auth/calendar.readonly"
     */
    scope?: string;
    /**
     * Additional custom parameters.
     * Cannot override reserved OAuth parameters.
     *
     * Array values are limited to 20 items per key to prevent DoS attacks.
     */
    extra?: Record<string, string | string[]>;
}
interface BuildLogoutUrlOptions {
    /**
     * The URL to which the user should be redirected after the logout.
     * @example 'https://example.com'
     */
    returnTo: string;
}
interface VerifyLogoutTokenOptions {
    /**
     * The logout token to verify.
     */
    logoutToken: string;
}
interface VerifyLogoutTokenResult {
    /**
     * The sid claim of the logout token.
     */
    sid: string;
    /**
     * The sub claim of the logout token.
     */
    sub: string;
}
interface AuthorizationDetails {
    readonly type: string;
    readonly [parameter: string]: unknown;
}
/**
 * Represents a successful token response from Auth0.
 *
 * Contains all tokens and metadata returned from Auth0 token endpoints,
 * including standard OAuth 2.0 tokens and optional OIDC tokens.
 */
declare class TokenResponse {
    /**
     * The access token retrieved from Auth0.
     */
    accessToken: string;
    /**
     * The id token retrieved from Auth0.
     */
    idToken?: string;
    /**
     * The refresh token retrieved from Auth0.
     */
    refreshToken?: string;
    /**
     * The time at which the access token expires (Unix timestamp in seconds).
     */
    expiresAt: number;
    /**
     * The scope of the access token.
     */
    scope?: string;
    /**
     * The claims of the id token.
     */
    claims?: IDToken;
    /**
     * The authorization details of the token response.
     */
    authorizationDetails?: AuthorizationDetails[];
    /**
     * The type of the token (typically "Bearer").
     */
    tokenType?: string;
    /**
     * A URI that identifies the type of the issued token (RFC 8693).
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc8693#section-3 RFC 8693 Section 3}
     * @example "urn:ietf:params:oauth:token-type:access_token"
     */
    issuedTokenType?: string;
    constructor(accessToken: string, expiresAt: number, idToken?: string, refreshToken?: string, scope?: string, claims?: IDToken, authorizationDetails?: AuthorizationDetails[]);
    /**
     * Create a TokenResponse from a TokenEndpointResponse (openid-client).
     *
     * Populates all standard OAuth 2.0 token response fields plus RFC 8693 extensions.
     * Safely handles responses that may not include all optional fields (e.g., ID token,
     * refresh token, issued_token_type).
     *
     * @param response The TokenEndpointResponse from the token endpoint.
     * @returns A TokenResponse instance with all available token data.
     */
    static fromTokenEndpointResponse(response: TokenEndpointResponse & TokenEndpointResponseHelpers): TokenResponse;
}
interface BackchannelAuthenticationOptions {
    /**
     * Human-readable message to be displayed at the consumption device and authentication device.
     * This allows the user to ensure the transaction initiated by the consumption device is the same that triggers the action on the authentication device.
     */
    bindingMessage: string;
    /**
     * The login hint to inform which user to use.
     */
    loginHint: {
        /**
         * The `sub` claim of the user that is trying to login using Client-Initiated Backchannel Authentication, and to which a push notification to authorize the login will be sent.
         */
        sub: string;
    };
    /**
     * Set a custom expiry time for the CIBA flow in seconds. Defaults to 300 seconds (5 minutes) if not set.
     */
    requestedExpiry?: number;
    /**
     * Optional authorization details to use Rich Authorization Requests (RAR).
     * @see https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests
     */
    authorizationDetails?: AuthorizationDetails[];
    /**
     * Authorization Parameters to be sent with the authorization request.
     */
    authorizationParams?: AuthorizationParameters;
}

/**
 * Auth0 authentication client for handling OAuth 2.0 and OIDC flows.
 *
 * Provides methods for authorization, token exchange, token refresh, and verification
 * of tokens issued by Auth0. Supports multiple authentication methods including
 * client_secret_post, private_key_jwt, and mTLS.
 */
declare class AuthClient {
    #private;
    constructor(options: AuthClientOptions);
    /**
     * Builds the URL to redirect the user-agent to to request authorization at Auth0.
     * @param options Options used to configure the authorization URL.
     *
     * @throws {BuildAuthorizationUrlError} If there was an issue when building the Authorization URL.
     *
     * @returns A promise resolving to an object, containing the authorizationUrl and codeVerifier.
     */
    buildAuthorizationUrl(options?: BuildAuthorizationUrlOptions): Promise<BuildAuthorizationUrlResult>;
    /**
     * Builds the URL to redirect the user-agent to to link a user account at Auth0.
     * @param options Options used to configure the link user URL.
     *
     * @throws {BuildLinkUserUrlError} If there was an issue when building the Link User URL.
     *
     * @returns A promise resolving to an object, containing the linkUserUrl and codeVerifier.
     */
    buildLinkUserUrl(options: BuildLinkUserUrlOptions): Promise<BuildLinkUserUrlResult>;
    /**
     * Builds the URL to redirect the user-agent to to unlink a user account at Auth0.
     * @param options Options used to configure the unlink user URL.
     *
     * @throws {BuildUnlinkUserUrlError} If there was an issue when building the Unlink User URL.
     *
     * @returns A promise resolving to an object, containing the unlinkUserUrl and codeVerifier.
     */
    buildUnlinkUserUrl(options: BuildUnlinkUserUrlOptions): Promise<BuildUnlinkUserUrlResult>;
    /**
     * Authenticates using Client-Initiated Backchannel Authentication.
     *
     * This method will initialize the backchannel authentication process with Auth0, and poll the token endpoint until the authentication is complete.
     *
     * Using Client-Initiated Backchannel Authentication requires the feature to be enabled in the Auth0 dashboard.
     * @see https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow
     * @param options Options used to configure the backchannel authentication process.
     *
     * @throws {BackchannelAuthenticationError} If there was an issue when doing backchannel authentication.
     *
     * @returns A Promise, resolving to the TokenResponse as returned from Auth0.
     */
    backchannelAuthentication(options: BackchannelAuthenticationOptions): Promise<TokenResponse>;
    /**
     * Initiates Client-Initiated Backchannel Authentication flow by calling the `/bc-authorize` endpoint.
     * This method only initiates the authentication request and returns the `auth_req_id` to be used in subsequent calls to `backchannelAuthenticationGrant`.
     *
     * Typically, you would call this method to start the authentication process, then use the returned `auth_req_id` to poll for the token using `backchannelAuthenticationGrant`.
     *
     * @param options Options used to configure the backchannel authentication initiation.
     *
     * @throws {BackchannelAuthenticationError} If there was an issue when initiating backchannel authentication.
     *
     * @returns An object containing `authReqId`, `expiresIn`, and `interval` for polling.
     */
    initiateBackchannelAuthentication(options: BackchannelAuthenticationOptions): Promise<{
        authReqId: string;
        expiresIn: number;
        interval: number | undefined;
    }>;
    /**
     * Exchanges the `auth_req_id` obtained from `initiateBackchannelAuthentication` for tokens.
     *
     * @param authReqId The `auth_req_id` obtained from `initiateBackchannelAuthentication`.
     *
     * @throws {BackchannelAuthenticationError} If there was an issue when exchanging the `auth_req_id` for tokens.
     *
     * @returns A Promise, resolving to the TokenResponse as returned from Auth0.
     */
    backchannelAuthenticationGrant({ authReqId }: {
        authReqId: string;
    }): Promise<TokenResponse>;
    /**
     * Retrieves a token for a connection using Token Vault.
     *
     * @deprecated Since v1.2.0. Use {@link exchangeToken} with a Token Vault payload:
     *   `exchangeToken({ connection, subjectToken, subjectTokenType, loginHint?, scope?, extra? })`.
     * This method remains for backward compatibility and is planned for removal in v2.0.
     *
     * This is a convenience wrapper around exchangeToken() for Token Vault scenarios,
     * providing a simpler API for the common use case of exchanging Auth0 tokens for
     * federated access tokens.
     *
     * Either a refresh token or access token must be provided, but not both. The method
     * automatically determines the correct subject_token_type based on which token is provided.
     *
     * @param options Options for retrieving an access token for a connection.
     *
     * @throws {TokenForConnectionError} If there was an issue requesting the access token,
     *                                    or if both/neither token types are provided.
     *
     * @returns The access token for the connection
     *
     * @see {@link exchangeToken} for the unified token exchange method with more options
     *
     * @example Using an access token (deprecated, use exchangeToken instead)
     * ```typescript
     * const response = await authClient.getTokenForConnection({
     *   connection: 'google-oauth2',
     *   accessToken: auth0AccessToken,
     *   loginHint: 'user@example.com'
     * });
     * ```
     *
     * @example Using a refresh token (deprecated, use exchangeToken instead)
     * ```typescript
     * const response = await authClient.getTokenForConnection({
     *   connection: 'salesforce',
     *   refreshToken: auth0RefreshToken
     * });
     * ```
     */
    getTokenForConnection(options: TokenForConnectionOptions): Promise<TokenResponse>;
    /**
     * @overload
     * Exchanges a custom token for Auth0 tokens using RFC 8693 Token Exchange via Token Exchange Profile.
     *
     * This overload is used when you DON'T provide a `connection` parameter.
     * It enables exchanging custom tokens (from MCP servers, legacy systems, or partner
     * services) for Auth0 tokens targeting a specific API audience. Requires a Token
     * Exchange Profile configured in Auth0.
     *
     * @param options Token Exchange Profile configuration (without `connection` parameter)
     * @returns Promise resolving to TokenResponse with Auth0 tokens
     * @throws {TokenExchangeError} When exchange fails or validation errors occur
     * @throws {MissingClientAuthError} When client authentication is not configured
     *
     * @example
     * ```typescript
     * const response = await authClient.exchangeToken({
     *   subjectTokenType: 'urn:acme:mcp-token',
     *   subjectToken: mcpServerToken,
     *   audience: 'https://api.example.com',
     *   scope: 'openid profile read:data'
     * });
     * ```
     */
    exchangeToken(options: ExchangeProfileOptions): Promise<TokenResponse>;
    /**
     * @overload
     * Exchanges an Auth0 token for an external provider's access token using Token Vault.
     *
     * This overload is used when you DO provide a `connection` parameter.
     * It exchanges Auth0 tokens (access or refresh) for external provider's access tokens
     * (Google, Facebook, etc.). The external provider's refresh token is securely stored in
     * Auth0's Token Vault.
     *
     * @param options Token Vault exchange configuration (with `connection` parameter)
     * @returns Promise resolving to TokenResponse with external provider's access token
     * @throws {TokenExchangeError} When exchange fails or validation errors occur
     * @throws {MissingClientAuthError} When client authentication is not configured
     *
     * @example
     * ```typescript
     * const response = await authClient.exchangeToken({
     *   connection: 'google-oauth2',
     *   subjectToken: auth0AccessToken,
     *   loginHint: 'user@example.com'
     * });
     * ```
     */
    exchangeToken(options: TokenVaultExchangeOptions): Promise<TokenResponse>;
    /**
     * Retrieves a token by exchanging an authorization code.
     * @param url The URL containing the authorization code.
     * @param options Options for exchanging the authorization code, containing the expected code verifier.
     *
     * @throws {TokenByCodeError} If there was an issue requesting the access token.
     *
     * @returns A Promise, resolving to the TokenResponse as returned from Auth0.
     */
    getTokenByCode(url: URL, options: TokenByCodeOptions): Promise<TokenResponse>;
    /**
     * Retrieves a token by exchanging a refresh token.
     * @param options Options for exchanging the refresh token.
     *
     * @throws {TokenByRefreshTokenError} If there was an issue requesting the access token.
     *
     * @returns A Promise, resolving to the TokenResponse as returned from Auth0.
     */
    getTokenByRefreshToken(options: TokenByRefreshTokenOptions): Promise<TokenResponse>;
    /**
     * Retrieves a token by exchanging client credentials.
     * @param options Options for retrieving the token.
     *
     * @throws {TokenByClientCredentialsError} If there was an issue requesting the access token.
     *
     * @returns A Promise, resolving to the TokenResponse as returned from Auth0.
     */
    getTokenByClientCredentials(options: TokenByClientCredentialsOptions): Promise<TokenResponse>;
    /**
     * Builds the URL to redirect the user-agent to to request logout at Auth0.
     * @param options Options used to configure the logout URL.
     * @returns A promise resolving to the URL to redirect the user-agent to.
     */
    buildLogoutUrl(options: BuildLogoutUrlOptions): Promise<URL>;
    /**
     * Verifies whether a logout token is valid.
     * @param options Options used to verify the logout token.
     *
     * @throws {VerifyLogoutTokenError} If there was an issue verifying the logout token.
     *
     * @returns An object containing the `sid` and `sub` claims from the logout token.
     */
    verifyLogoutToken(options: VerifyLogoutTokenOptions): Promise<VerifyLogoutTokenResult>;
}

/**
 * Interface to represent an OAuth2 error.
 */
interface OAuth2Error {
    error: string;
    error_description: string;
    message?: string;
}
/**
 * Error codes used for {@link NotSupportedError}
 */
declare enum NotSupportedErrorCode {
    PAR_NOT_SUPPORTED = "par_not_supported_error",
    MTLS_WITHOUT_CUSTOMFETCH_NOT_SUPPORT = "mtls_without_custom_fetch_not_supported"
}
/**
 * Error thrown when a feature is not supported.
 * For example, when trying to use Pushed Authorization Requests (PAR) but the Auth0 tenant was not configured to support it.
 */
declare class NotSupportedError extends Error {
    code: string;
    constructor(code: string, message: string);
}
/**
 * Base class for API errors, containing the error, error_description and message (if available).
 */
declare abstract class ApiError extends Error {
    cause?: OAuth2Error;
    code: string;
    constructor(code: string, message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when trying to get an access token.
 */
declare class TokenByCodeError extends ApiError {
    constructor(message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when trying to get an access token.
 */
declare class TokenByClientCredentialsError extends ApiError {
    constructor(message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when trying to get an access token.
 */
declare class TokenByRefreshTokenError extends ApiError {
    constructor(message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when trying to get an access token for a connection.
 *
 * @deprecated Since v1.2.0. Use {@link TokenExchangeError} instead, as {@link getTokenForConnection}
 * is deprecated in favor of {@link exchangeToken}.
 * This error class remains for backward compatibility and is planned for removal in v2.0.
 */
declare class TokenForConnectionError extends ApiError {
    constructor(message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when a Token Exchange flow fails. This can occur due to misconfiguration,
 * an invalid subject_token, or if the exchange is denied by the server.
 */
declare class TokenExchangeError extends ApiError {
    constructor(message: string, cause?: OAuth2Error);
}
/**
 * Error thrown when verifying the logout token.
 */
declare class VerifyLogoutTokenError extends Error {
    code: string;
    constructor(message: string);
}
/**
 * Error thrown when trying to use Client-Initiated Backchannel Authentication.
 */
declare class BackchannelAuthenticationError extends ApiError {
    code: string;
    constructor(cause?: OAuth2Error);
}
/**
 * Error thrown when trying to build the authorization URL.
 */
declare class BuildAuthorizationUrlError extends ApiError {
    constructor(cause?: OAuth2Error);
}
/**
 * Error thrown when trying to build the Link User URL.
 */
declare class BuildLinkUserUrlError extends ApiError {
    constructor(cause?: OAuth2Error);
}
/**
 * Error thrown when trying to build the Unlink User URL.
 */
declare class BuildUnlinkUserUrlError extends ApiError {
    constructor(cause?: OAuth2Error);
}
/**
 * Error thrown when Client Secret or Client Assertion Signing Key is missing.
 */
declare class MissingClientAuthError extends Error {
    code: string;
    constructor();
}

export { AuthClient, type AuthClientOptions, type AuthorizationDetails, type AuthorizationParameters, BackchannelAuthenticationError, type BackchannelAuthenticationOptions, BuildAuthorizationUrlError, type BuildAuthorizationUrlOptions, type BuildAuthorizationUrlResult, BuildLinkUserUrlError, type BuildLinkUserUrlOptions, type BuildLinkUserUrlResult, type BuildLogoutUrlOptions, BuildUnlinkUserUrlError, type BuildUnlinkUserUrlOptions, type BuildUnlinkUserUrlResult, type ExchangeProfileOptions, MissingClientAuthError, NotSupportedError, NotSupportedErrorCode, type OAuth2Error, TokenByClientCredentialsError, type TokenByClientCredentialsOptions, TokenByCodeError, type TokenByCodeOptions, TokenByRefreshTokenError, type TokenByRefreshTokenOptions, TokenExchangeError, TokenForConnectionError, type TokenForConnectionOptions, TokenResponse, type TokenVaultExchangeOptions, VerifyLogoutTokenError, type VerifyLogoutTokenOptions, type VerifyLogoutTokenResult };
